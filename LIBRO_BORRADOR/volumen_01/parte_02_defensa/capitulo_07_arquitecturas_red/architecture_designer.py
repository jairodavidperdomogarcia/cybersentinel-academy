#!/usr/bin/env python3

import argparse
import json
from typing import Any, Dict, List


class ArchitectureDesigner:
    def __init__(self, scenario: str = "generic") -> None:
        self.scenario = scenario
        self.control_library = self._load_control_library()

    def _load_control_library(self) -> Dict[str, List[Dict[str, Any]]]:
        return {
            "perimeter": [
                {"name": "WAF", "cost": 5000, "effectiveness": 0.85},
                {"name": "DDoS Protection", "cost": 3000, "effectiveness": 0.90},
                {"name": "API Gateway", "cost": 8000, "effectiveness": 0.75},
            ],
            "network": [
                {"name": "VLAN Segmentation", "cost": 2000, "effectiveness": 0.70},
                {"name": "Firewall Rules", "cost": 1500, "effectiveness": 0.65},
                {"name": "Network Monitoring", "cost": 4000, "effectiveness": 0.80},
            ],
            "endpoint": [
                {"name": "EDR", "cost": 10000, "effectiveness": 0.88},
                {"name": "CIS Hardening", "cost": 3000, "effectiveness": 0.60},
                {"name": "Patch Management", "cost": 5000, "effectiveness": 0.75},
            ],
            "application": [
                {"name": "Input Validation", "cost": 4000, "effectiveness": 0.85},
                {"name": "Rate Limiting", "cost": 2000, "effectiveness": 0.90},
                {"name": "Authentication MFA", "cost": 3000, "effectiveness": 0.95},
            ],
            "data": [
                {"name": "Encryption at Rest", "cost": 6000, "effectiveness": 0.99},
                {"name": "Encryption in Transit", "cost": 3000, "effectiveness": 0.95},
                {"name": "Data Masking", "cost": 2500, "effectiveness": 0.70},
            ],
        }

    def suggest_controls_from_threats(self, threats_file: str) -> Dict[str, Any]:
        with open(threats_file, "r", encoding="utf-8") as f:
            data = json.load(f)

        threats: List[Dict[str, Any]] = []
        if isinstance(data, dict):
            if "threats" in data:
                threats = data.get("threats", [])
            elif "top_threats" in data:
                threats = data.get("top_threats", [])
        elif isinstance(data, list):
            threats = data

        suggestions: Dict[str, Any] = {}
        for threat in threats:
            layer = str(threat.get("layer", threat.get("layer_name", ""))).lower()
            stride = threat.get("stride_category")
            name = threat.get("name") or threat.get("id") or "threat"

            if not layer and stride:
                stride_map = {
                    "spoofing": "application",
                    "tampering": "application",
                    "repudiation": "application",
                    "information disclosure": "data",
                    "denial of service": "perimeter",
                    "elevation of privilege": "application",
                }
                key = stride.lower()
                layer = stride_map.get(key, "network")

            layer_controls = self.control_library.get(layer, [])
            suggested = layer_controls[:3]

            suggestions[name] = {
                "threat": threat,
                "layer": layer,
                "suggested_controls": suggested,
            }

        return suggestions

    def generate_mermaid_diagram(self, components: List[Dict[str, Any]]) -> str:
        mermaid_lines: List[str] = []
        mermaid_lines.append("graph TD")
        mermaid_lines.append("    %% Architecture Diagram - Generated by ArchitectureDesigner")

        zone_colors = {
            "patient": "#FF6B6B",
            "hospital": "#4ECDC4",
            "cloud": "#45B7D1",
            "internet": "#96CEB4",
        }

        for comp in components:
            name = str(comp.get("name", "Component"))
            node_id = name.replace(" ", "")
            zone = str(comp.get("zone", "")).lower()
            color = zone_colors.get(zone, "#CCCCCC")
            mermaid_lines.append(f'    {node_id}["{name}"]')
            mermaid_lines.append(f"    style {node_id} fill:{color}")

        connections = [
            ("IoTDevice", "MedicalGateway", "TLS 1.3"),
            ("MedicalGateway", "APIGateway", "JWT Auth"),
            ("APIGateway", "BackendServer", "Rate Limited"),
        ]

        for src, dst, label in connections:
            mermaid_lines.append(f'    {src} -->|"{label}"| {dst}')

        mermaid_lines.append("")
        mermaid_lines.append("    %% Trust Boundaries")
        mermaid_lines.append('    subgraph "Patient Zone (Low Trust)"')
        mermaid_lines.append("        IoTDevice")
        mermaid_lines.append("    end")
        mermaid_lines.append('    subgraph "Hospital Zone (Medium Trust)"')
        mermaid_lines.append("        MedicalGateway")
        mermaid_lines.append("    end")
        mermaid_lines.append('    subgraph "Cloud Zone (High Trust)"')
        mermaid_lines.append("        APIGateway")
        mermaid_lines.append("        BackendServer")
        mermaid_lines.append("        Database")
        mermaid_lines.append("    end")

        return "\n".join(mermaid_lines)

    def calculate_architecture_roi(
        self, ale: float, proposed_controls: List[Dict[str, Any]]
    ) -> float:
        if not proposed_controls:
            return 0.0

        total_control_cost = sum(float(c.get("cost", 0)) for c in proposed_controls)
        if total_control_cost <= 0:
            return 0.0

        effectiveness_values = [
            float(c.get("effectiveness", 0)) for c in proposed_controls
        ]
        avg_effectiveness = sum(effectiveness_values) / len(effectiveness_values)

        reduced_ale = ale * (1 - avg_effectiveness)
        roi = ((ale - reduced_ale - total_control_cost) / total_control_cost) * 100
        return roi

    def load_components(self, path: str) -> List[Dict[str, Any]]:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, list):
            return data
        if isinstance(data, dict) and "components" in data:
            return data.get("components", [])
        return []

    def load_controls(self, path: str) -> List[Dict[str, Any]]:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, list):
            return data
        if isinstance(data, dict) and "controls" in data:
            return data.get("controls", [])
        return []

    def export_config(
        self,
        output_file: str,
        components: List[Dict[str, Any]],
        controls: List[Dict[str, Any]],
    ) -> None:
        config = {
            "scenario": self.scenario,
            "components": components,
            "controls": controls,
        }
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Asistente para diseño de arquitecturas seguras"
    )
    parser.add_argument(
        "--scenario",
        type=str,
        default="generic",
        help="Escenario base (meditech, techsafelock, industrial, etc.)",
    )
    parser.add_argument(
        "--threats",
        type=str,
        help="Archivo JSON con amenazas del Cap 06",
    )
    parser.add_argument(
        "--suggest-controls",
        action="store_true",
        help="Sugerir controles a partir de amenazas",
    )
    parser.add_argument(
        "--components",
        type=str,
        help="Archivo JSON con componentes arquitecturales",
    )
    parser.add_argument(
        "--generate-diagram",
        action="store_true",
        help="Generar diagrama Mermaid de la arquitectura",
    )
    parser.add_argument(
        "--controls",
        type=str,
        help="Archivo JSON con controles propuestos",
    )
    parser.add_argument(
        "--ale",
        type=float,
        help="Annualized Loss Expectancy estimada",
    )
    parser.add_argument(
        "--calculate-roi",
        action="store_true",
        help="Calcular ROI de la arquitectura propuesta",
    )
    parser.add_argument(
        "--export-config",
        type=str,
        help="Ruta de salida para exportar configuración completa",
    )
    return parser


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    designer = ArchitectureDesigner(scenario=args.scenario)

    if args.suggest_controls:
        if not args.threats:
            parser.error("--threats es obligatorio con --suggest-controls")
        suggestions = designer.suggest_controls_from_threats(args.threats)
        print(json.dumps(suggestions, indent=2, ensure_ascii=False))
        return

    if args.generate_diagram:
        if not args.components:
            parser.error("--components es obligatorio con --generate-diagram")
        components = designer.load_components(args.components)
        diagram = designer.generate_mermaid_diagram(components)
        print(diagram)
        return

    if args.calculate_roi:
        if not args.controls or args.ale is None:
            parser.error("--controls y --ale son obligatorios con --calculate-roi")
        controls = designer.load_controls(args.controls)
        roi = designer.calculate_architecture_roi(args.ale, controls)
        print(f"{roi:.2f}")
        return

    if args.export_config:
        if not args.components or not args.controls:
            parser.error("--components y --controls son obligatorios con --export-config")
        components = designer.load_components(args.components)
        controls = designer.load_controls(args.controls)
        designer.export_config(args.export_config, components, controls)
        print(args.export_config)
        return

    parser.print_help()


if __name__ == "__main__":
    main()

